{"type_of":"article","id":240339,"title":"How To Immutably Update An Array In TypeScript","description":"Using an array to collect objects is useful. But, it presents some challenges with searching and upda...","cover_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--pxwXJYPh--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://res.cloudinary.com/practicaldev/image/fetch/s--FGU7MeG6--/c_imagga_scale%2Cf_auto%2Cfl_progressive%2Ch_420%2Cq_auto%2Cw_1000/https://dev-to-uploads.s3.amazonaws.com/i/dzw7cmo5bdjklzas0nmg.jpg","readable_publish_date":"Jan 31","social_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--glZBiizu--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://res.cloudinary.com/practicaldev/image/fetch/s--FGU7MeG6--/c_imagga_scale%2Cf_auto%2Cfl_progressive%2Ch_420%2Cq_auto%2Cw_1000/https://dev-to-uploads.s3.amazonaws.com/i/dzw7cmo5bdjklzas0nmg.jpg","slug":"how-to-immutably-update-an-array-in-typescript-54nm","path":"/shelob9/how-to-immutably-update-an-array-in-typescript-54nm","url":"https://dev.to/shelob9/how-to-immutably-update-an-array-in-typescript-54nm","canonical_url":"https://dev.to/shelob9/how-to-immutably-update-an-array-in-typescript-54nm","comments_count":5,"positive_reactions_count":16,"collection_id":null,"created_at":"2020-01-17T22:31:17Z","edited_at":null,"crossposted_at":null,"published_at":"2020-01-31T22:58:15Z","last_comment_at":"2020-02-01T18:54:06Z","published_timestamp":"2020-01-31T22:58:15Z","tag_list":"typescript, javascript, react","tags":["typescript","javascript","react"],"body_html":"<p>Using an array to collect objects is useful. But, it presents some challenges with searching and updating the data. In React, updating an object in an array will not cause re-renders, adding more complication.</p>\n\n<p>This article does not aim to provide a great explanation of what immutability means in this context. This recent post from CSS tricks <a href=\"https://css-tricks.com/understanding-immutability-in-javascript/\">explains the concept of immutability in JavaScript</a> quite well.</p>\n\n<h2>\n  <a name=\"the-problem\" href=\"#the-problem\" class=\"anchor\">\n  </a>\n  The Problem\n</h2>\n\n<p>An array is an object, and objects are React's state management tracks objects by reference.<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight jsx\"><code>\n<span class=\"kd\">const</span> <span class=\"nx\">items</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">One</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n<span class=\"p\">];</span>\n\n<span class=\"k\">return</span> <span class=\"p\">(</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">onClick=</span><span class=\"si\">{</span><span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">items</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">({</span><span class=\"na\">id</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">})</span><span class=\"si\">}</span><span class=\"p\">&gt;</span>Add Item<span class=\"p\">&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n    <span class=\"si\">{</span><span class=\"nx\">items</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span> <span class=\"nx\">item</span> <span class=\"o\">=&gt;</span> <span class=\"p\">&lt;</span><span class=\"nc\">Item</span> <span class=\"na\">key=</span><span class=\"si\">{</span><span class=\"nx\">item</span><span class=\"p\">.</span><span class=\"nx\">id</span><span class=\"si\">}</span> <span class=\"err\">{</span><span class=\"p\">...</span><span class=\"nt\">item</span><span class=\"err\">}</span> <span class=\"p\">/&gt;)</span><span class=\"si\">}</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n\n</code></pre></div>\n\n\n\n<p>To make this work, we need a new array, not an updated array. Instead of updating the array -- a mutation -- we need to return a new array.</p>\n\n<h2>\n  <a name=\"the-solution\" href=\"#the-solution\" class=\"anchor\">\n  </a>\n  The Solution\n</h2>\n\n<p>I want to avoid clever abstractions on top of array searches and updates that I have. Sorting and searching large collections of objects can become a performance issue. Avoiding an abstraction or dependency helps a bit. So, basically I keep cutting and pasting the same code, so I figured if I put it on dev.to, I could find it via internet search. I'm glad that you may find it useful as well.</p>\n\n<p>These examples work with a collection of objects that use this type:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"nx\">type</span> <span class=\"nx\">field</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n  <span class=\"nl\">label</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div>\n\n\n\n<p>You can use whatever type you want. The searches are based off of the id property. </p>\n\n<h3>\n  <a name=\"immutably-adding-or-adding-an-item-to-an-array\" href=\"#immutably-adding-or-adding-an-item-to-an-array\" class=\"anchor\">\n  </a>\n  Immutably Adding Or Adding An Item To An Array\n</h3>\n\n<p>This function makes use of <code>Array.findIndex()</code> to locate the index of the field being updated in the collection. If it's not present, the item is added to the array. If the item does is found, the existing items in the array are sliced into two -- the items before and the items after -- with the updated item placed in between:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"k\">export</span> <span class=\"kd\">const</span> <span class=\"nx\">addOrUpdateField</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n  <span class=\"nx\">field</span><span class=\"p\">:</span> <span class=\"nx\">field</span><span class=\"p\">,</span>\n  <span class=\"nx\">fields</span><span class=\"p\">:</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"nx\">field</span><span class=\"o\">&gt;</span>\n<span class=\"p\">):</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"nx\">field</span><span class=\"o\">&gt;</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">findIndex</span><span class=\"p\">((</span><span class=\"na\">f</span><span class=\"p\">:</span> <span class=\"nx\">field</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">field</span><span class=\"p\">.</span><span class=\"nx\">id</span> <span class=\"o\">===</span> <span class=\"nx\">f</span><span class=\"p\">.</span><span class=\"nx\">id</span><span class=\"p\">);</span>\n  <span class=\"c1\">//Not found, add on end.</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">===</span> <span class=\"nx\">index</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">[...</span><span class=\"nx\">fields</span><span class=\"p\">,</span> <span class=\"nx\">field</span><span class=\"p\">];</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">//found, so return:</span>\n  <span class=\"c1\">//Clone of items before item being update.</span>\n  <span class=\"c1\">//updated item</span>\n  <span class=\"c1\">//Clone of items after item being updated.</span>\n  <span class=\"k\">return</span> <span class=\"p\">[...</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">index</span><span class=\"p\">),</span> <span class=\"nx\">field</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">index</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)];</span>\n<span class=\"p\">};</span>\n</code></pre></div>\n\n\n\n<p>Notice that instead of <code>Array.push()</code>, I'm returning a new array, with the existing items spread in. I can prove that this is returning a different object, with this test:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code>\n<span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Adds fields immutably</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">intitalFields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[]);</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">).</span><span class=\"nx\">not</span><span class=\"p\">.</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n\n</code></pre></div>\n\n\n\n<p>It is important to me that adding and removing items maintains order, which is why I used <code>Array.slice()</code>. These tests prove adding and removing works, and maintains the order:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code> <span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Removes field, maintaining order</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">intitalFields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">One</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n    <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n  <span class=\"p\">]);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">intitalFields</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">removeField</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n\n<span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Adds a field</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[]);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n\n<span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Adds a second field</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">intitalFields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[]);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">intitalFields</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n  <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n\n</code></pre></div>\n\n\n\n<h3>\n  <a name=\"immutably-removing-an-item-from-an-array\" href=\"#immutably-removing-an-item-from-an-array\" class=\"anchor\">\n  </a>\n  Immutably Removing An Item From An Array\n</h3>\n\n<p>Ok, one more thing while I'm here, though this could be it's own post: immutably removing item.</p>\n\n<p>This function also relies on <code>Array.findIndex()</code>. If no item is found, the field collection is returned unmodified. If it is found, I use <code>Array.slice()</code> to cut the array in two again: items before and items after. This time only those two pieces are returned:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code>\n<span class=\"k\">export</span> <span class=\"kd\">const</span> <span class=\"nx\">removeField</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n  <span class=\"nx\">fieldId</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span>\n  <span class=\"nx\">fields</span><span class=\"p\">:</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"nx\">field</span><span class=\"o\">&gt;</span>\n<span class=\"p\">):</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"nx\">field</span><span class=\"o\">&gt;</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">findIndex</span><span class=\"p\">((</span><span class=\"na\">f</span><span class=\"p\">:</span> <span class=\"nx\">field</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">fieldId</span> <span class=\"o\">===</span> <span class=\"nx\">f</span><span class=\"p\">.</span><span class=\"nx\">id</span><span class=\"p\">);</span>\n  <span class=\"c1\">//Not found, return same reference.</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">===</span> <span class=\"nx\">index</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">fields</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">//Return clone of items before and clone of items after.</span>\n  <span class=\"k\">return</span> <span class=\"p\">[...</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">index</span><span class=\"p\">),</span> <span class=\"p\">...</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">index</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)];</span>\n<span class=\"p\">};</span>\n\n</code></pre></div>\n\n\n\n<p>I can prove that fields are removed, and order is maintained, with this test:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code> <span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Removes field, maintaining order</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">intitalFields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">One</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n      <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n    <span class=\"p\">]);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">intitalFields</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">removeField</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">id</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n\n</code></pre></div>\n\n\n\n<p>BTW I'm using the <code>addOrUpdateField</code> function, which does make this an integration test, not a unit test. Also, I don't care. I like this kind of functional programming with arrays.</p>\n\n<p>I care that it works the way I want it to. So I care that it updates immutably when used how I'm actually going to use it:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code> <span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Removes field immutably</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">intitalFields</span> <span class=\"o\">=</span> <span class=\"nx\">addOrUpdateField</span><span class=\"p\">({</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Three</span><span class=\"dl\">'</span> <span class=\"p\">},</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">1</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">One</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n      <span class=\"p\">{</span> <span class=\"na\">id</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">label</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Two</span><span class=\"dl\">'</span> <span class=\"p\">},</span>\n    <span class=\"p\">]);</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">fields</span> <span class=\"o\">=</span> <span class=\"nx\">removeField</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">fields</span><span class=\"p\">).</span><span class=\"nx\">not</span><span class=\"p\">.</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"nx\">intitalFields</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n</code></pre></div>\n\n\n\n","body_markdown":"Using an array to collect objects is useful. But, it presents some challenges with searching and updating the data. In React, updating an object in an array will not cause re-renders, adding more complication.\n\nThis article does not aim to provide a great explanation of what immutability means in this context. This recent post from CSS tricks [explains the concept of immutability in JavaScript](https://css-tricks.com/understanding-immutability-in-javascript/) quite well.\n\n## The Problem\n\nAn array is an object, and objects are React's state management tracks objects by reference. \n\n```jsx\n\nconst items = [\n  { id: 1, label: 'One' },\n  { id: 2, label: 'Two' },\n  { id: 3, label: 'Three' },\n];\n\nreturn (\n<div>\n    <button onClick={() => items.push({id:5})}>Add Item</button>\n    {items.map( item => <Item key={item.id} {...item} />)}\n</div>\n\n```\n\nTo make this work, we need a new array, not an updated array. Instead of updating the array -- a mutation -- we need to return a new array.\n\n## The Solution\n\nI want to avoid clever abstractions on top of array searches and updates that I have. Sorting and searching large collections of objects can become a performance issue. Avoiding an abstraction or dependency helps a bit. So, basically I keep cutting and pasting the same code, so I figured if I put it on dev.to, I could find it via internet search. I'm glad that you may find it useful as well.\n\n\nThese examples work with a collection of objects that use this type:\n\n```ts\ntype field = {\n  id: string;\n  label: string;\n};\n```\n\nYou can use whatever type you want. The searches are based off of the id property. \n\n### Immutably Adding Or Adding An Item To An Array \n\nThis function makes use of `Array.findIndex()` to locate the index of the field being updated in the collection. If it's not present, the item is added to the array. If the item does is found, the existing items in the array are sliced into two -- the items before and the items after -- with the updated item placed in between:\n\n```ts\nexport const addOrUpdateField = (\n  field: field,\n  fields: Array<field>\n): Array<field> => {\n  const index = fields.findIndex((f: field) => field.id === f.id);\n  //Not found, add on end.\n  if (-1 === index) {\n    return [...fields, field];\n  }\n  //found, so return:\n  //Clone of items before item being update.\n  //updated item\n  //Clone of items after item being updated.\n  return [...fields.slice(0, index), field, ...fields.slice(index + 1)];\n};\n```\n\nNotice that instead of `Array.push()`, I'm returning a new array, with the existing items spread in. I can prove that this is returning a different object, with this test:\n\n```ts\n\nit('Adds fields immutably', () => {\n    const intitalFields = addOrUpdateField({ id: '2', label: 'Two' }, []);\n    const fields = addOrUpdateField({ id: '3', label: 'Three' }, intitalFields);\n    expect(fields).not.toBe(intitalFields);\n  });\n\n```\n\nIt is important to me that adding and removing items maintains order, which is why I used `Array.slice()`. These tests prove adding and removing works, and maintains the order:\n\n\n```ts\n it('Removes field, maintaining order', () => {\n  const intitalFields = addOrUpdateField({ id: '3', label: 'Three' }, [\n    { id: '1', label: 'One' },\n    { id: '2', label: 'Two' },\n  ]);\n  expect(intitalFields.length).toBe(3);\n  const fields = removeField('2', intitalFields);\n  expect(fields.length).toBe(2);\n  expect(fields[0].id).toBe('1');\n  expect(fields[1].id).toBe('3');\n});\n\nit('Adds a field', () => {\n  let fields = addOrUpdateField({ id: '3', label: 'Three' }, []);\n  expect(fields[0].id).toBe('3');\n});\n\nit('Adds a second field', () => {\n  const intitalFields = addOrUpdateField({ id: '2', label: 'Two' }, []);\n  expect(intitalFields[0].id).toBe('2');\n  const fields = addOrUpdateField({ id: '3', label: 'Three' }, intitalFields);\n  expect(fields[0].id).toBe('2');\n  expect(fields[1].id).toBe('3');\n});\n\n```\n\n### Immutably Removing An Item From An Array \n\nOk, one more thing while I'm here, though this could be it's own post: immutably removing item.\n\nThis function also relies on `Array.findIndex()`. If no item is found, the field collection is returned unmodified. If it is found, I use `Array.slice()` to cut the array in two again: items before and items after. This time only those two pieces are returned:\n\n```ts\n\nexport const removeField = (\n  fieldId: string,\n  fields: Array<field>\n): Array<field> => {\n  const index = fields.findIndex((f: field) => fieldId === f.id);\n  //Not found, return same reference.\n  if (-1 === index) {\n    return fields;\n  }\n  //Return clone of items before and clone of items after.\n  return [...fields.slice(0, index), ...fields.slice(index + 1)];\n};\n\n```\n\nI can prove that fields are removed, and order is maintained, with this test:\n\n```ts\n it('Removes field, maintaining order', () => {\n    const intitalFields = addOrUpdateField({ id: '3', label: 'Three' }, [\n      { id: '1', label: 'One' },\n      { id: '2', label: 'Two' },\n    ]);\n    expect(intitalFields.length).toBe(3);\n    const fields = removeField('2', intitalFields);\n    expect(fields.length).toBe(2);\n    expect(fields[0].id).toBe('1');\n    expect(fields[1].id).toBe('3');\n  });\n\n```\n\nBTW I'm using the `addOrUpdateField` function, which does make this an integration test, not a unit test. Also, I don't care. I like this kind of functional programming with arrays.\n\n I care that it works the way I want it to. So I care that it updates immutably when used how I'm actually going to use it:\n\n```ts\n it('Removes field immutably', () => {\n    const intitalFields = addOrUpdateField({ id: '3', label: 'Three' }, [\n      { id: '1', label: 'One' },\n      { id: '2', label: 'Two' },\n    ]);\n    const fields = removeField('2', intitalFields);\n    expect(fields).not.toBe(intitalFields);\n  });\n```\n\n ","user":{"name":"Josh Pollock","username":"shelob9","twitter_username":"Josh412","github_username":"Shelob9","website_url":"https://JoshPress.net","profile_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--0WBb8dNZ--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/63421/1ce6f212-f8bc-417a-b61e-92a6743899dd.jpg","profile_image_90":"https://res.cloudinary.com/practicaldev/image/fetch/s--8WFtOwoJ--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/63421/1ce6f212-f8bc-417a-b61e-92a6743899dd.jpg"}}