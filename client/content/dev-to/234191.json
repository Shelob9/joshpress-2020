{"type_of":"article","id":234191,"title":"Testing Node's Event Emitter","description":"","cover_image":null,"readable_publish_date":"Jan 24","social_image":"https://dev.to/social_previews/article/234191.png","slug":"testing-event-emitter-38b5","path":"/shelob9/testing-event-emitter-38b5","url":"https://dev.to/shelob9/testing-event-emitter-38b5","canonical_url":"https://dev.to/shelob9/testing-event-emitter-38b5","comments_count":0,"positive_reactions_count":8,"collection_id":null,"created_at":"2020-01-07T22:38:54Z","edited_at":"2020-01-24T21:41:38Z","crossposted_at":null,"published_at":"2020-01-24T21:41:23Z","last_comment_at":"2020-01-24T21:41:23Z","published_timestamp":"2020-01-24T21:41:23Z","tag_list":"typescript, node, testing","tags":["typescript","node","testing"],"body_html":"<p>Today at work, I implemented a basic event system using <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">Node's EventEmitter</a> class. I am developing a state management system to aid in migrating a part of <a href=\"http://calderaforms.com/\">a WordPress plugin</a>'s admin interface from jQuery and Handlebars to React. </p>\n\n<p>Our immediate goal is to fix some performance issues related to storing state in the DOM. I'm developing this API decoupled from the main Git repo for the plugin so I can work faster. This repo has unit tests, and the main git repo for the plugin will have acceptance tests proving that the system works in the plugin.</p>\n\n<p>One type of test I'd never written before was to cover the events emitted with that event emitter. My logic is that if <a href=\"https://testing-library.com/docs/guiding-principles\">we're supposed to test our application like it is used</a>, then we should test developer APIs like they are used. Use the comments to tell me any better approaches you may have.</p>\n\n<h2>\n  <a name=\"testing-the-event-emitter\" href=\"#testing-the-event-emitter\" class=\"anchor\">\n  </a>\n  Testing The Event Emitter\n</h2>\n\n<p>The plugin this is for is a form builder plugin. The code being tested manages the state of the forms in the form editor. In the test code below,<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Emits remove field event</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Mock the event callback to see that:</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">callback</span> <span class=\"o\">=</span> <span class=\"nx\">jest</span><span class=\"p\">.</span><span class=\"nx\">fn</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// This is a factory function</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"nx\">fieldState</span><span class=\"p\">([</span><span class=\"nx\">field</span><span class=\"p\">]);</span>\n\n    <span class=\"c1\">//Bind jest's mock function to the event.</span>\n    <span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">feildEvents</span><span class=\"p\">.</span><span class=\"nx\">on</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">removeField</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">fieldId</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"nx\">fieldId</span><span class=\"p\">));</span>\n\n    <span class=\"c1\">//Do the thing that triggers the event</span>\n    <span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">removeField</span><span class=\"p\">(</span><span class=\"nx\">field</span><span class=\"p\">.</span><span class=\"nx\">id</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">//Did callback get called once?  </span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">).</span><span class=\"nx\">toBeCalledTimes</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"c1\">//Did callback get called with the right data?</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">).</span><span class=\"nx\">toBeCalledWith</span><span class=\"p\">(</span><span class=\"nx\">field</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n\n\n\n<p>What I'm doing here is, instantiating my state management system, pretty much how it will actually get used, and then doing the thing that triggers the event and making sure the callback gets the right data. </p>\n\n<h2>\n  <a name=\"it-could-be-more-isolated\" href=\"#it-could-be-more-isolated\" class=\"anchor\">\n  </a>\n  It Could Be More Isolated\n</h2>\n\n<p>So, yes, this is more of an integration test than a unit test. I could have invoked the event directly. But, I didn't add that event emitter so I'd have something cute to write about on the internet. I needed to do something with the data the callback passes.</p>\n\n<p>The test I wrote looks more like the actual code that is bound to the event I'm testing, than any unit test would look like. I don't care that an instance of <code>EventEmitter</code> emits events, I care that it emits the right event, with the right data at the right time.</p>\n\n<p>I added the event emitter beacuse updating the field list wasn't updating the generated list of \"magic tags\" -- merge tags based on field values and other settings. So, really the most important tests here were showing that adding and removing fields change the total list of magic tags:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight typescript\"><code><span class=\"nx\">it</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Adds field magic tag when adding a field</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Start with 1 field</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"nx\">cfEditorState</span><span class=\"p\">({</span>\n      <span class=\"na\">intialFields</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n         <span class=\"c1\">//...</span>\n        <span class=\"p\">},</span>\n      <span class=\"p\">],</span>\n    <span class=\"p\">});</span>\n    <span class=\"c1\">// Has one magic tag</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">getAllMagicTags</span><span class=\"p\">().</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">//Add a field</span>\n    <span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">addField</span><span class=\"p\">({</span>\n      <span class=\"c1\">//...</span>\n    <span class=\"p\">});</span>\n\n     <span class=\"c1\">// Has two magic tags</span>\n    <span class=\"nx\">expect</span><span class=\"p\">(</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">getAllMagicTags</span><span class=\"p\">().</span><span class=\"nx\">length</span><span class=\"p\">).</span><span class=\"nx\">toBe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n</code></pre></div>\n\n\n\n<p>This test covers that the event was fired, with the right data, and had the right effect. I have tests with less scope than that, which were helpful to have on the journey to getting this test to pass. But, this one final test makes sure everything works together.</p>\n\n<h2>\n  <a name=\"typing-events\" href=\"#typing-events\" class=\"anchor\">\n  </a>\n  Typing Events\n</h2>\n\n<p>This passed in my tests, but made compilation fail. The error I had was I was not extending the base event emitter. So when I exported the events object, TypeScript's compiler was not happy. A little googling later and I learned you can't export an internal in TypeScript. </p>\n\n<p>And like, whatever, I found a solution on <a href=\"https://github.com/Morglod/tsee\">Github called <code>tsee</code></a> and it let's me type my events. That's really cool. </p>\n\n<p>The one thing I don't like about event-based architecture is if the code emitting the event changes, the callback can break. This can happen accidently, beacuse it's not always obvious what is bound to an event. Typeing the events should help.</p>\n\n<p>The one thing I don't like about event-based architecture is if the code emitting the event changes, the callback can break. This can happen accidently, beacuse it's not always obvious what is bound to an event. Typeing the events should help.</p>\n\n<p>Before I made the change I had:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight shell\"><code>import EventEmitter from <span class=\"s1\">'events'</span><span class=\"p\">;</span>\n</code></pre></div>\n\n\n\n<p>I updated that to:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight shell\"><code>import <span class=\"o\">{</span> EventEmitter <span class=\"o\">}</span> from <span class=\"s1\">'tsee'</span><span class=\"p\">;</span>\n</code></pre></div>\n\n\n\n<p>Then I was able to type the event emitter:<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight shell\"><code>const fieldEvents <span class=\"o\">=</span> new EventEmitter&lt;<span class=\"o\">{</span>\n    addField: <span class=\"o\">(</span>fieldId: fieldId<span class=\"o\">)</span> <span class=\"o\">=&gt;</span> void<span class=\"p\">;</span>\n    updateField: <span class=\"o\">(</span>args: <span class=\"o\">{</span> fieldId: fieldId<span class=\"p\">;</span> beforeUpdate: field <span class=\"o\">})</span> <span class=\"o\">=&gt;</span> void<span class=\"p\">;</span>\n    removeField: <span class=\"o\">(</span>field: field<span class=\"o\">)</span> <span class=\"o\">=&gt;</span> void<span class=\"p\">;</span>\n  <span class=\"o\">}&gt;()</span><span class=\"p\">;</span>\n</code></pre></div>\n\n\n\n<h2>\n  <a name=\"a-fun-event\" href=\"#a-fun-event\" class=\"anchor\">\n  </a>\n  A Fun Event\n</h2>\n\n<p>Event-based architecture is useful. Instead of piling more responsiblities into a function or file, sometimes it's better to open it to modification from the outside world. But, it also means the function has side effects. </p>\n\n<p>Testing side effects is always difficult, in this post, I've shown one way to test that the data supplied to the callbacks is consistent. In this post you also learned how to use TypeScript to make it harder to make the kinds of mistakes this test prevents. Adding tests, and typing the events does not mean that they can't be consumed incorrectly, but it's a step in the right direction.</p>\n\n<p><em>Featured image by <a href=\"https://unsplash.com/@arizonanthony?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Anthony Cantin</a> on <a href=\"/s/photos/sky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></em></p>\n\n","body_markdown":"\nToday at work, I implemented a basic event system using [Node's EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter) class. I am developing a state management system to aid in migrating a part of [a WordPress plugin](http://calderaforms.com/)'s admin interface from jQuery and Handlebars to React. \n\nOur immediate goal is to fix some performance issues related to storing state in the DOM. I'm developing this API decoupled from the main Git repo for the plugin so I can work faster. This repo has unit tests, and the main git repo for the plugin will have acceptance tests proving that the system works in the plugin.\n\nOne type of test I'd never written before was to cover the events emitted with that event emitter. My logic is that if [we're supposed to test our application like it is used](https://testing-library.com/docs/guiding-principles), then we should test developer APIs like they are used. Use the comments to tell me any better approaches you may have.\n\n## Testing The Event Emitter\n\nThe plugin this is for is a form builder plugin. The code being tested manages the state of the forms in the form editor. In the test code below, \n \n\n```ts\nit('Emits remove field event', () => {\n    // Mock the event callback to see that:\n    const callback = jest.fn();\n\n    // This is a factory function\n    const state = fieldState([field]);\n\n    //Bind jest's mock function to the event.\n    state.feildEvents.on('removeField', fieldId => callback(fieldId));\n\n    //Do the thing that triggers the event\n    state.removeField(field.id);\n\n    //Did callback get called once?  \n    expect(callback).toBeCalledTimes(1);\n    //Did callback get called with the right data?\n    expect(callback).toBeCalledWith(field);\n});\n```\n\nWhat I'm doing here is, instantiating my state management system, pretty much how it will actually get used, and then doing the thing that triggers the event and making sure the callback gets the right data. \n\n## It Could Be More Isolated\n\nSo, yes, this is more of an integration test than a unit test. I could have invoked the event directly. But, I didn't add that event emitter so I'd have something cute to write about on the internet. I needed to do something with the data the callback passes.\n\nThe test I wrote looks more like the actual code that is bound to the event I'm testing, than any unit test would look like. I don't care that an instance of `EventEmitter` emits events, I care that it emits the right event, with the right data at the right time.\n\nI added the event emitter beacuse updating the field list wasn't updating the generated list of \"magic tags\" -- merge tags based on field values and other settings. So, really the most important tests here were showing that adding and removing fields change the total list of magic tags:\n\n```ts\nit('Adds field magic tag when adding a field', () => {\n    // Start with 1 field\n    const state = cfEditorState({\n      intialFields: [\n        {\n         //...\n        },\n      ],\n    });\n    // Has one magic tag\n    expect(state.getAllMagicTags().length).toBe(1);\n\n    //Add a field\n    state.addField({\n      //...\n    });\n\n     // Has two magic tags\n    expect(state.getAllMagicTags().length).toBe(2);\n  });\n```\n\nThis test covers that the event was fired, with the right data, and had the right effect. I have tests with less scope than that, which were helpful to have on the journey to getting this test to pass. But, this one final test makes sure everything works together.\n\n\n## Typing Events\n\nThis passed in my tests, but made compilation fail. The error I had was I was not extending the base event emitter. So when I exported the events object, TypeScript's compiler was not happy. A little googling later and I learned you can't export an internal in TypeScript. \n\nAnd like, whatever, I found a solution on [Github called `tsee`](https://github.com/Morglod/tsee) and it let's me type my events. That's really cool. \n\n\nThe one thing I don't like about event-based architecture is if the code emitting the event changes, the callback can break. This can happen accidently, beacuse it's not always obvious what is bound to an event. Typeing the events should help.\n\n\nThe one thing I don't like about event-based architecture is if the code emitting the event changes, the callback can break. This can happen accidently, beacuse it's not always obvious what is bound to an event. Typeing the events should help.\n\n\nBefore I made the change I had:\n\n```bash\nimport EventEmitter from 'events';\n```\n\nI updated that to:\n\n```bash\nimport { EventEmitter } from 'tsee';\n```\n\nThen I was able to type the event emitter:\n\n```bash\nconst fieldEvents = new EventEmitter<{\n    addField: (fieldId: fieldId) => void;\n    updateField: (args: { fieldId: fieldId; beforeUpdate: field }) => void;\n    removeField: (field: field) => void;\n  }>();\n```\n\n## A Fun Event\n\nEvent-based architecture is useful. Instead of piling more responsiblities into a function or file, sometimes it's better to open it to modification from the outside world. But, it also means the function has side effects. \n\nTesting side effects is always difficult, in this post, I've shown one way to test that the data supplied to the callbacks is consistent. In this post you also learned how to use TypeScript to make it harder to make the kinds of mistakes this test prevents. Adding tests, and typing the events does not mean that they can't be consumed incorrectly, but it's a step in the right direction.\n\n<em>Featured image by <a href=\"https://unsplash.com/@arizonanthony?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Anthony Cantin</a> on <a href=\"/s/photos/sky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></em>","user":{"name":"Josh Pollock","username":"shelob9","twitter_username":"Josh412","github_username":"Shelob9","website_url":"https://JoshPress.net","profile_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--0WBb8dNZ--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/63421/1ce6f212-f8bc-417a-b61e-92a6743899dd.jpg","profile_image_90":"https://res.cloudinary.com/practicaldev/image/fetch/s--8WFtOwoJ--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/63421/1ce6f212-f8bc-417a-b61e-92a6743899dd.jpg"}}